import serial
import time
import sys
import struct
import subprocess
# import secrets
import logging
 
def read32bitData(ser):
    data = 0
    for i in range(4):
        tmp = ser.read()
        data = data + (int.from_bytes(tmp , byteorder=sys.byteorder) << (i * 8))
        time.sleep(0.2)
    return data
 
def read64bitData(ser):
    data = 0
    for i in range(8):
        tmp = ser.read()
        data = data + (int.from_bytes(tmp , byteorder=sys.byteorder) << (i * 8))
        time.sleep(0.2)
    return data
 
def uart_write_byte(ser, val):
    # length = 8
    # tmp = ('%%0%dx' % (length << 1) % val).decode('hex')[-length:]
    tmp = struct.pack(">B", val)
    print(tmp)
    # ser.write
    # ser.write(val.to_bytes(1, byteorder='big'))
 
def start_aes():
 
    com_port = serial.Serial(
        port='COM4',
        baudrate=115200,
        bytesize=serial.EIGHTBITS,
        parity=serial.PARITY_NONE,
        stopbits=serial.STOPBITS_ONE,
        timeout = 5
    )
   
    com_port.close()
    cmd = [0x20]
    com_port.open()
 
    #com_port.write(bytes((bytearray(cmd))))
    #time.sleep(0.2)
    #tmp =  list(com_port.read(8))
    # tmp =  list(bytearray(com_port.read(8)))
    #print(tmp)
 
    # ## Encryption
    # time.sleep(2)
    for i in range(1):
        cmd = [0xAE, 0x7B, 0xE9, 0x59, 0x01, 0xBD, 0x9F, 0x48, 0x31, 0x7B, 0xE9, 0x59, 0x01, 0xBD, 0x9F, 0x48, 0x31]
        com_port.write(bytes((bytearray(cmd))))
        time.sleep(0.2)
     
        if com_port.in_waiting >= 16:
            tmp = list(com_port.read(16))
            logging.info(" AES encryption successful")
            logging.info(tmp)
        else:
            logging.info("board no response.")
            
        #tmp =  list(com_port.read(16))
        #print(tmp)
 
    #cmd = [0x1D]
    #com_port.write(bytes((bytearray(cmd))))
    #time.sleep(0.2)
    #tmp =  list(com_port.read(8))
    #print(tmp)
 
    com_port.close()
    return True

'''
This script provides an example of how to make use of Embedded Glitcher through VC Glitcher SDK API calls
A sequence of random glitches will be generated to the 'digital glitch' port of VC Glitcher device

Riscure BV, 2012
'''
from vcglitcher import *

import random
import numpy as np
import logging
import serial
import time

SERIAL_PORT = "COM4"
BAUDRATE = 115200


def dig_glitch(glitch_voltage_p):
    """
    Configures the VC Glitcher and triggers a digital glitch sequence.
    """
    
    vcg = VCGlitcher()

    # Print SDK snapshot version
    print vcg.sdk_is_snapshot_version()
    print "SDK Snapshot Version: {}".format(vcg.sdk_is_snapshot_version())
    # List devices and get information about the first device
    vcg.device_list()
    vcg.device_get_info(0)
    
    # Open the device
    vcg.open()
    print "Device opened successfully."
    # Opening VC Glitcher device
    print "Device opened successfully."
    #print "Device opened successfully."

    # Set glitch mode to Embedded VCC
    l = vcg.set_mode(GLITCH_MODE.EMBEDDED_VCC)
    print(l)
    #for glitch_voltage in np.arange(-7.4, 4.3, 0.5):
    #    print "Testing glitch voltage: {:.2f}".format(glitch_voltage)
    #    time.sleep(0.2)
    glitch_voltage = glitch_voltage_p
    vcg.set_vcc_glitch_parameter(4.0,4.0,glitch_voltage) 
    vcg.pattern_enable()
    print "Glitcher availability: {}".format(vcg.evcg_is_available())
    print "Glitcher version: {}".format(vcg.get_version())
    print "Glitcher availability: {}".format(vcg.evcg_is_available())

    # Clear any previous patterns

    # Add a glitch pattern (delay=400ns, duration=400ns)
    oi = vcg.evcg_get_guaranteed_pattern_number()
    print(oi)
    #for i in range(1,4):
    print("Clearing existing patterns...")
    vcg.evcg_clear_pattern()  # This should free up space
    print("Patterns cleared. Now adding a new pattern.")

    vcg.evcg_add_pattern(100, 100)
    #vcg.evcg_add_pattern(100, 300)
    #vcg.evcg_add_pattern(400,350)
    #vcg.evcg_add_pattern(400,300)
    #print(vcg.evcg_set_pattern())
    # Configure smartcard reset and glitch trigger
    #vcg.smartcard_reset_config(RST_SRC.EVCG, EVCG_RST_POLARITY.ACTIVE_LOW)  # Use reset generated by Embedded Glitcher
    vi = vcg.evcg_trigger_config(EVCG_TRIGGER_SRC.TRIGGER_IN, EVCG_TRIGGER_EDGE.RISING)  # Trigger by software
    print(vi)

    # Commit the glitch sequence and arm the glitcher
    vcg.evcg_set_pattern()
    #vcg.evcg_set_arm(True)  # Arm Embedded Glitcher for any trigger
     # Clear any bad patterns
    vcg.evcg_set_arm(True)  # Re-arm glitcher

    # Start the glitching process
    u = vcg.evcg_soft_start()
    start_aes() 
    print "Soft start result: {}".format(u)
    print "Glitch triggered."  # Generate software trigger; glitches should be seen on the 'digital glitch' port
    logging.info("Soft start result: {} | Glitch voltage: {:.2f}V".format(u, glitch_voltage_p))

    # Wait for the glitch sequence to complete
    start_wait_time = time.time()
    while vcg.evcg_busy():
        if time.time() - start_wait_time > 5:  # If stuck for 5 seconds
            print("Board unresponsive! Resetting...")
            reset_pinata()  # Call reset function
            break
    vcg.evcg_set_arm(False)  # Disarm Embedded Glitcher
    vcg.close()  # Close the device
    return
    print "Glitcher device closed successfully."                                                         # Closing VC Glitcher device
    logging.info("Glitch execution completed successfully. Duration: {:.2f}s".format(time.time() - start_time))

RELAY_PORT = "COM7"  

def toggle_relay_off():
    ser = serial.Serial(RELAY_PORT, 9600, timeout=1)

    command1 = "A0 01 01 A2"
    command_bytes1 = bytearray.fromhex(command1)
    ser.write(command_bytes1)
    ser.close()

def toggle_relay_on():
    ser = serial.Serial(RELAY_PORT, 9600, timeout=1)

    command2 = "A0 01 00 A1"
    command_bytes2 = bytearray.fromhex(command2)
    ser.write(command_bytes2)
    ser.close()
     

def reset_pinata():
    print("Powering off...")
    toggle_relay_off()  
    time.sleep(1)      
    
    print("powering on....")
    toggle_relay_on()
    time.sleep(0)

    print("Reset complete!")
#reset_pinata()




if __name__ == "__main__":
    # Run the reset sequence
    reset_pinata()
        #trigger_generated = start_aes()
    start_time = time.time()  # Store start time
            #logging.info("Starting overnight glitch testing...")
    print("Start Time:",start_time)
            #print("Start Time:", time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(start_time)))
    log_filename = "glitch_log" + str(start_time) + ".txt"
    logging.basicConfig(filename=log_filename, level=logging.INFO, format="%(asctime)s - %(message)s")
            #duration =  10  
            #glitch_voltage_list = list(np.arange(-7.4, 4.3, 0.1))
    
    left_sweep = np.arange(-7.4, -5.11, 0.1)
    fine_grained_interval = np.arange(-5.10, -4.89, 0.01)
    right_sweep = np.arange(-4.89, 4.21, 0.1)

    glitch_voltage_list = np.concatenate((left_sweep, fine_grained_interval, right_sweep))
    glitch_voltage_list = np.round(glitch_voltage_list, 3) 
            #log this print statement
            #while time.time() - start_time < duration: 
    for glitch_voltage_p in glitch_voltage_list:
        for i in range(50):
                    #if trigger_generated:
            print("###",i,glitch_voltage_p)
            print "Trigger detected (HIGH). Running digital glitch..."
            logging.info("Iteration {} | Glitch Voltage: {:.2f}V".format(i, glitch_voltage_p))
            time.sleep(2)
            dig_glitch(glitch_voltage_p)
                    # else:
                        #print "No trigger detected. Skipping glitch."
        end_time = time.time()
        elapsed_time = end_time - start_time
        logging.info("Overnight testing completed. Total execution time: {:.2f} seconds".format(elapsed_time))
        print("Execution Time: {:.2f} seconds".format(elapsed_time))
   
