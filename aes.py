import serial
import time
import sys
import struct
import subprocess
# import secrets
 
def read32bitData(ser):
    data = 0
    for i in range(4):
        tmp = ser.read()
        data = data + (int.from_bytes(tmp , byteorder=sys.byteorder) << (i * 8))
        time.sleep(0.2)
    return data
 
def read64bitData(ser):
    data = 0
    for i in range(8):
        tmp = ser.read()
        data = data + (int.from_bytes(tmp , byteorder=sys.byteorder) << (i * 8))
        time.sleep(0.2)
    return data
 
def uart_write_byte(ser, val):
    # length = 8
    # tmp = ('%%0%dx' % (length << 1) % val).decode('hex')[-length:]
    tmp = struct.pack(">B", val)
    print(tmp)
    # ser.write
    # ser.write(val.to_bytes(1, byteorder='big'))
 
def start_aes():
 
    com_port = serial.Serial(
        port='COM4',
        baudrate=115200,
        bytesize=serial.EIGHTBITS,
        parity=serial.PARITY_NONE,
        stopbits=serial.STOPBITS_ONE,
        timeout = 5
    )
   
    com_port.close()
    cmd = [0x20]
    com_port.open()
 
    #com_port.write(bytes((bytearray(cmd))))
    #time.sleep(0.2)
    #tmp =  list(com_port.read(8))
    # tmp =  list(bytearray(com_port.read(8)))
    #print(tmp)
 
    # ## Encryption
    # time.sleep(2)
    for i in range(1):
        cmd = [0xAE, 0x7B, 0xE9, 0x59, 0x01, 0xBD, 0x9F, 0x48, 0x31, 0x7B, 0xE9, 0x59, 0x01, 0xBD, 0x9F, 0x48, 0x31]
        com_port.write(bytes((bytearray(cmd))))
        time.sleep(0.2)
     
        if com_port.in_waiting >= 16:
            tmp = list(com_port.read(16))
            print(tmp)
        else:
            print("Looks like I'm getting influenced by Mr.E.M waves here.")
            
        #tmp =  list(com_port.read(16))
        #print(tmp)
 
    #cmd = [0x1D]
    #com_port.write(bytes((bytearray(cmd))))
    #time.sleep(0.2)
    #tmp =  list(com_port.read(8))
    #print(tmp)
 
    com_port.close()
    return True

'''
This script provides an example of how to make use of Embedded Glitcher through VC Glitcher SDK API calls
A sequence of random glitches will be generated to the 'digital glitch' port of VC Glitcher device

Riscure BV, 2012
'''
from vcglitcher import *
import random
import numpy as np


def dig_glitch():
    """
    Configures the VC Glitcher and triggers a digital glitch sequence.
    """
    vcg = VCGlitcher()

    # Print SDK snapshot version
    print vcg.sdk_is_snapshot_version()

    # List devices and get information about the first device
    vcg.device_list()
    vcg.device_get_info(0)

    # Open the device
    vcg.open()  # Opening VC Glitcher device
    print "Device opened successfully."


    # Set glitch mode to Embedded VCC
    vcg.set_mode(GLITCH_MODE.EMBEDDED_VCC)
    for glitch_voltage in np.arange(-7.4, 4.3, 0.5):
        print "Testing glitch voltage: {:.2f}".format(glitch_voltage)
    #    time.sleep(0.2)
    vcg.set_vcc_glitch_parameter(4.0,4.0,glitch_voltage) 
    vcg.pattern_enable()
    print "Glitcher availability: {}".format(vcg.evcg_is_available())
    print "Glitcher version: {}".format(vcg.get_version())

    # Clear any previous patterns
    vcg.evcg_clear_pattern()

    # Add a glitch pattern (delay=400ns, duration=400ns)
    oi = vcg.evcg_get_guaranteed_pattern_number()
    print(oi)
    #for i in range(1,4):

    vcg.evcg_add_pattern(4, 4)
    # vcg.evcg_add_pattern(200, 200)
    #vcg.evcg_add_pattern(100, 300)
    #vcg.evcg_add_pattern(400,350)
    #vcg.evcg_add_pattern(400,300)
    #print(vcg.evcg_set_pattern())
    # Configure smartcard reset and glitch trigger
    vcg.smartcard_reset_config(RST_SRC.EVCG, EVCG_RST_POLARITY.ACTIVE_LOW)  # Use reset generated by Embedded Glitcher
    vi = vcg.evcg_trigger_config(EVCG_TRIGGER_SRC.TRIGGER_IN, EVCG_TRIGGER_EDGE.RISING)  # Trigger by software
    print(vi)

    # Commit the glitch sequence and arm the glitcher
    vcg.evcg_set_pattern()  # Commit glitch sequence into Embedded Glitcher
    vcg.evcg_set_arm(True)  # Arm Embedded Glitcher for any trigger

    # Start the glitching process
    u = vcg.evcg_soft_start()
    
    start_aes() 
    print "Soft start result: {}".format(u)
    print "Glitch triggered."  # Generate software trigger; glitches should be seen on the 'digital glitch' port

    # Wait for the glitch sequence to complete
    #while vcg.evcg_busy():
        #print(vcg.evcg_busy())
        #pass  # Keep checking if the glitch sequence is complete

    # Disarm and close the glitcher
    vcg.evcg_set_arm(False)  # Disarm Embedded Glitcher
    vcg.close()  # Close the device
    print "Glitcher device closed successfully."                                                         # Closing VC Glitcher device


'''def set_pulse_amplitude():

    vcg = VCGlitcher()
        # Set the VCC glitch parameters
    vcg.set_vcc_glitch_parameter(6.0,5.0,-3.3)
    '''




if __name__ == "__main__":
    #trigger_generated = start_aes()  
    for i in range(3):
    #if trigger_generated:
        print "Trigger detected (HIGH). Running digital glitch..."
        dig_glitch()
        # start_aes()
    # else:
        #print "No trigger detected. Skipping glitch."